// Generated by CIRCT firtool-1.48.0
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define 'PRINTF_COND' to add an extra gate to prints.
`ifndef PRINTF_COND_
  `ifdef PRINTF_COND
    `define PRINTF_COND_ (`PRINTF_COND)
  `else  // PRINTF_COND
    `define PRINTF_COND_ 1
  `endif // PRINTF_COND
`endif // not def PRINTF_COND_

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module UART_rx(
  input        clock,
               reset,
               io_i_serial_data,
  output       io_o_rx_done,
  output [7:0] io_o_data
);

  reg [9:0] clkCnterReg;
  reg [3:0] bitCnterReg;
  reg       outDataReg_0;
  reg       outDataReg_1;
  reg       outDataReg_2;
  reg       outDataReg_3;
  reg       outDataReg_4;
  reg       outDataReg_5;
  reg       outDataReg_6;
  reg       outDataReg_7;
  reg       outRxDoneReg;
  reg [1:0] stateReg;
  reg       serialDataReg_REG;
  reg       serialDataReg;
  always @(posedge clock) begin
    if (reset) begin
      clkCnterReg <= 10'h0;
      bitCnterReg <= 4'h0;
      outDataReg_0 <= 1'h0;
      outDataReg_1 <= 1'h0;
      outDataReg_2 <= 1'h0;
      outDataReg_3 <= 1'h0;
      outDataReg_4 <= 1'h0;
      outDataReg_5 <= 1'h0;
      outDataReg_6 <= 1'h0;
      outDataReg_7 <= 1'h0;
      outRxDoneReg <= 1'h0;
      stateReg <= 2'h0;
    end
    else begin
      automatic logic            _GEN;
      automatic logic            _GEN_0;
      automatic logic            _GEN_1;
      automatic logic            _GEN_2;
      automatic logic            _GEN_3;
      automatic logic            _GEN_4;
      automatic logic [3:0][9:0] _GEN_5;
      automatic logic [3:0][1:0] _GEN_6;
      _GEN = stateReg == 2'h0;
      _GEN_0 = stateReg == 2'h1;
      _GEN_1 = clkCnterReg < 10'hA0;
      _GEN_2 = stateReg == 2'h2;
      _GEN_3 = clkCnterReg < 10'h140;
      _GEN_4 = _GEN | _GEN_0;
      _GEN_5 =
        {{_GEN_3 ? clkCnterReg + 10'h1 : 10'h0},
         {_GEN_3 ? clkCnterReg + 10'h1 : 10'h0},
         {_GEN_1 ? clkCnterReg + 10'h1 : 10'h0},
         {10'h0}};
      clkCnterReg <= _GEN_5[stateReg];
      if (_GEN)
        bitCnterReg <= 4'h0;
      else if (_GEN_0 | ~_GEN_2 | _GEN_3) begin
      end
      else if (bitCnterReg[3])
        bitCnterReg <= 4'h0;
      else
        bitCnterReg <= bitCnterReg + 4'h1;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | (|(bitCnterReg[2:0]))) begin
      end
      else
        outDataReg_0 <= serialDataReg;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | bitCnterReg[2:0] != 3'h1) begin
      end
      else
        outDataReg_1 <= serialDataReg;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | bitCnterReg[2:0] != 3'h2) begin
      end
      else
        outDataReg_2 <= serialDataReg;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | bitCnterReg[2:0] != 3'h3) begin
      end
      else
        outDataReg_3 <= serialDataReg;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | bitCnterReg[2:0] != 3'h4) begin
      end
      else
        outDataReg_4 <= serialDataReg;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | bitCnterReg[2:0] != 3'h5) begin
      end
      else
        outDataReg_5 <= serialDataReg;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | bitCnterReg[2:0] != 3'h6) begin
      end
      else
        outDataReg_6 <= serialDataReg;
      if (_GEN_4 | ~_GEN_2 | _GEN_3 | bitCnterReg[2:0] != 3'h7) begin
      end
      else
        outDataReg_7 <= serialDataReg;
      outRxDoneReg <= ~_GEN & (~(_GEN_0 | _GEN_2) & (&stateReg) & ~_GEN_3 | outRxDoneReg);
      _GEN_6 =
        {{{2{_GEN_3}}},
         {{1'h1, bitCnterReg == 4'h8}},
         {_GEN_1 ? 2'h1 : {~serialDataReg, 1'h0}},
         {{1'h0, ~serialDataReg}}};
      stateReg <= _GEN_6[stateReg];
    end
    serialDataReg_REG <= io_i_serial_data;
    serialDataReg <= serialDataReg_REG;
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        clkCnterReg = _RANDOM[/*Zero width*/ 1'b0][9:0];
        bitCnterReg = _RANDOM[/*Zero width*/ 1'b0][13:10];
        outDataReg_0 = _RANDOM[/*Zero width*/ 1'b0][14];
        outDataReg_1 = _RANDOM[/*Zero width*/ 1'b0][15];
        outDataReg_2 = _RANDOM[/*Zero width*/ 1'b0][16];
        outDataReg_3 = _RANDOM[/*Zero width*/ 1'b0][17];
        outDataReg_4 = _RANDOM[/*Zero width*/ 1'b0][18];
        outDataReg_5 = _RANDOM[/*Zero width*/ 1'b0][19];
        outDataReg_6 = _RANDOM[/*Zero width*/ 1'b0][20];
        outDataReg_7 = _RANDOM[/*Zero width*/ 1'b0][21];
        outRxDoneReg = _RANDOM[/*Zero width*/ 1'b0][22];
        stateReg = _RANDOM[/*Zero width*/ 1'b0][24:23];
        serialDataReg_REG = _RANDOM[/*Zero width*/ 1'b0][25];
        serialDataReg = _RANDOM[/*Zero width*/ 1'b0][26];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_o_rx_done = outRxDoneReg;
  assign io_o_data =
    {outDataReg_7,
     outDataReg_6,
     outDataReg_5,
     outDataReg_4,
     outDataReg_3,
     outDataReg_2,
     outDataReg_1,
     outDataReg_0};
endmodule

module MidiProc(
  input         clock,
                reset,
                io_en,
                io_midi_in,
  output [31:0] io_freq,
  output        io_note_on,
                io_note_off
);

  wire               _uart_r_io_o_rx_done;
  wire [7:0]         _uart_r_io_o_data;
  wire [127:0][31:0] _GEN =
    {32'h1323F1,
     32'h1210EE,
     32'h110D5A,
     32'h101858,
     32'hF3116,
     32'hE56CF,
     32'hD88C8,
     32'hCC652,
     32'hC0EC5,
     32'hB6186,
     32'hABE00,
     32'hA23A8,
     32'h991F9,
     32'h90877,
     32'h886AD,
     32'h80C2C,
     32'h7988B,
     32'h72B68,
     32'h6C464,
     32'h66329,
     32'h60763,
     32'h5B0C3,
     32'h55F00,
     32'h511D4,
     32'h4C8FC,
     32'h4843C,
     32'h44357,
     32'h40616,
     32'h3CC46,
     32'h395B4,
     32'h36232,
     32'h33194,
     32'h303B1,
     32'h2D862,
     32'h2AF80,
     32'h288EA,
     32'h2647E,
     32'h2421E,
     32'h221AB,
     32'h2030B,
     32'h1E623,
     32'h1CADA,
     32'h1B119,
     32'h198CA,
     32'h181D9,
     32'h16C31,
     32'h157C0,
     32'h14475,
     32'h1323F,
     32'h1210F,
     32'h110D6,
     32'h10186,
     32'hF311,
     32'hE56D,
     32'hD88D,
     32'hCC65,
     32'hC0EC,
     32'hB618,
     32'hABE0,
     32'hA23A,
     32'h9920,
     32'h9087,
     32'h886B,
     32'h80C3,
     32'h7989,
     32'h72B6,
     32'h6C46,
     32'h6633,
     32'h6076,
     32'h5B0C,
     32'h55F0,
     32'h511D,
     32'h4C90,
     32'h4844,
     32'h4435,
     32'h4061,
     32'h3CC4,
     32'h395B,
     32'h3623,
     32'h3319,
     32'h303B,
     32'h2D86,
     32'h2AF8,
     32'h288F,
     32'h2648,
     32'h2422,
     32'h221B,
     32'h2031,
     32'h1E62,
     32'h1CAE,
     32'h1B12,
     32'h198D,
     32'h181E,
     32'h16C3,
     32'h157C,
     32'h1447,
     32'h1324,
     32'h1211,
     32'h110D,
     32'h1018,
     32'hF31,
     32'hE57,
     32'hD89,
     32'hCC6,
     32'hC0F,
     32'hB62,
     32'hABE,
     32'hA24,
     32'h992,
     32'h908,
     32'h887,
     32'h80C,
     32'h799,
     32'h72B,
     32'h6C4,
     32'h663,
     32'h607,
     32'h5B1,
     32'h55F,
     32'h512,
     32'h4C9,
     32'h484,
     32'h443,
     32'h406,
     32'h3CC,
     32'h396,
     32'h362,
     32'h332};
  reg  [7:0]         byte_r;
  reg  [1:0]         state;
  reg  [3:0]         sbyte;
  reg  [6:0]         note;
  reg  [6:0]         velocity;
  reg                note_on;
  reg                note_off;
  `ifndef SYNTHESIS
    always @(posedge clock) begin
      if ((`PRINTF_COND_) & note_on & ~reset)
        $fwrite(32'h80000002, "NOTE_ON: %d\n", note);
      if ((`PRINTF_COND_) & note_off & ~reset)
        $fwrite(32'h80000002, "NOTE_OFF: %d\n", note);
    end // always @(posedge)
  `endif // not def SYNTHESIS
  always @(posedge clock) begin
    if (reset) begin
      byte_r <= 8'h0;
      state <= 2'h0;
      sbyte <= 4'h0;
      note <= 7'h0;
      velocity <= 7'h0;
      note_on <= 1'h0;
      note_off <= 1'h0;
    end
    else begin
      automatic logic _GEN_0;
      automatic logic _GEN_1;
      automatic logic _GEN_2;
      automatic logic _GEN_3;
      automatic logic _GEN_4;
      automatic logic _GEN_5;
      automatic logic _GEN_6;
      automatic logic _GEN_7;
      automatic logic _GEN_8;
      _GEN_0 = state == 2'h0;
      _GEN_1 = state == 2'h1;
      _GEN_2 = sbyte == 4'h9;
      _GEN_3 = sbyte == 4'h8;
      _GEN_4 = _GEN_2 | _GEN_3;
      _GEN_5 = state == 2'h2;
      _GEN_6 = _GEN_5 & _uart_r_io_o_rx_done;
      _GEN_7 = velocity == 7'h0;
      _GEN_8 = _GEN_0 | _GEN_1;
      if ((_GEN_0 | _GEN_1 | _GEN_5) & _uart_r_io_o_rx_done)
        byte_r <= _uart_r_io_o_data;
      if (_GEN_0) begin
        if (_uart_r_io_o_rx_done)
          state <= 2'h1;
      end
      else begin
        automatic logic _GEN_9;
        _GEN_9 = _uart_r_io_o_rx_done & (_GEN_2 | _GEN_3);
        if (_GEN_1) begin
          if (_GEN_9)
            state <= 2'h2;
        end
        else if (_GEN_5 & _GEN_9)
          state <= 2'h0;
      end
      if (_GEN_0 & _uart_r_io_o_rx_done)
        sbyte <= byte_r[3:0];
      if (_GEN_0 | ~(_GEN_1 & _uart_r_io_o_rx_done & _GEN_4)) begin
      end
      else
        note <= byte_r[6:0];
      if (_GEN_8 | ~(_GEN_6 & _GEN_4)) begin
      end
      else
        velocity <= byte_r[6:0];
      note_on <=
        ~note_on & (~_GEN_8 & _GEN_5 & _uart_r_io_o_rx_done & _GEN_2 & ~_GEN_7 | note_on);
      note_off <=
        ~note_off
        & (_GEN_8 | ~_GEN_6 ? note_off : _GEN_2 ? _GEN_7 | note_off : _GEN_3 | note_off);
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        byte_r = _RANDOM[/*Zero width*/ 1'b0][7:0];
        state = _RANDOM[/*Zero width*/ 1'b0][9:8];
        sbyte = _RANDOM[/*Zero width*/ 1'b0][13:10];
        note = _RANDOM[/*Zero width*/ 1'b0][20:14];
        velocity = _RANDOM[/*Zero width*/ 1'b0][27:21];
        note_on = _RANDOM[/*Zero width*/ 1'b0][28];
        note_off = _RANDOM[/*Zero width*/ 1'b0][29];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  UART_rx uart_r (
    .clock            (clock),
    .reset            (reset),
    .io_i_serial_data (io_midi_in),
    .io_o_rx_done     (_uart_r_io_o_rx_done),
    .io_o_data        (_uart_r_io_o_data)
  );
  assign io_freq = _GEN[note];
  assign io_note_on = note_on;
  assign io_note_off = note_off;
endmodule

