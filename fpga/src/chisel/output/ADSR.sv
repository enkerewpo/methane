// Generated by CIRCT firtool-1.48.0
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module ADSR(
  input         clock,
                reset,
                io_en,
                io_note_on,
                io_note_off,
  input  [31:0] io_attack,
                io_decay,
                io_sustain,
                io_release,
  input  [2:0]  io_attack_curve_type,
                io_decay_curve_type,
                io_release_curve_type,
  output [31:0] io_out
);

  reg [2:0]  state;
  reg [31:0] counter;
  reg [31:0] out;
  reg [31:0] attack_k;
  reg [31:0] decay_k;
  reg [31:0] release_k;
  reg [31:0] attack_a;
  reg [31:0] decay_a;
  reg [31:0] release_a;
  always @(posedge clock) begin
    if (reset) begin
      state <= 3'h0;
      counter <= 32'h0;
      out <= 32'h0;
      attack_k <= 32'h0;
      decay_k <= 32'h0;
      release_k <= 32'h0;
      attack_a <= 32'h0;
      decay_a <= 32'h0;
      release_a <= 32'h0;
    end
    else begin
      automatic logic [31:0]      _decay_a_T = 32'hFFFFFFFF - io_sustain;
      automatic logic [63:0]      _GEN = {32'h0, io_attack};
      automatic logic [63:0]      _GEN_0 = {32'h0, io_decay};
      automatic logic [63:0]      _GEN_1 = {32'h0, io_release};
      automatic logic             _GEN_2;
      automatic logic             _GEN_3;
      automatic logic             _GEN_4;
      automatic logic             _GEN_5;
      automatic logic [31:0]      _out_T_9;
      automatic logic             _GEN_6;
      automatic logic [31:0]      _out_T_24;
      automatic logic [7:0][31:0] _GEN_7;
      automatic logic [7:0][31:0] _GEN_8;
      automatic logic [63:0]      _attack_a_T_1 = 64'hFFFFFFFF / (_GEN * _GEN);
      automatic logic [63:0]      _decay_a_T_3 = {32'h0, _decay_a_T} / (_GEN_0 * _GEN_0);
      automatic logic [63:0]      _release_a_T_1 =
        {32'h0, io_sustain} / (_GEN_1 * _GEN_1);
      _GEN_2 = counter == io_attack;
      _GEN_3 = io_note_off | _GEN_2;
      _GEN_4 = counter == io_decay;
      _GEN_5 = io_note_off | _GEN_4;
      _out_T_9 = io_decay - counter;
      _GEN_6 = counter == io_release;
      _out_T_24 = io_release - counter;
      if (state == 3'h0) begin
        if (io_note_on)
          state <= 3'h1;
      end
      else if (state == 3'h1) begin
        if (io_note_off)
          state <= 3'h4;
        else if (_GEN_2)
          state <= 3'h2;
      end
      else if (state == 3'h2) begin
        if (io_note_off)
          state <= 3'h4;
        else if (_GEN_4)
          state <= 3'h3;
      end
      else if (state == 3'h3) begin
        if (io_note_off)
          state <= 3'h4;
      end
      else if (state == 3'h4 & _GEN_6)
        state <= 3'h0;
      _GEN_7 =
        {{counter},
         {counter},
         {counter},
         {_GEN_6 ? 32'h0 : counter + 32'h1},
         {io_note_off ? 32'h0 : counter},
         {_GEN_5 ? 32'h0 : counter + 32'h1},
         {_GEN_3 ? 32'h0 : counter + 32'h1},
         {io_note_on ? 32'h0 : counter}};
      counter <= _GEN_7[state];
      _GEN_8 =
        {{out},
         {out},
         {out},
         {_GEN_6
            ? 32'h0
            : io_release_curve_type == 3'h0
                ? io_sustain - release_k * counter
                : io_release_curve_type == 3'h1
                    ? release_a * _out_T_24 * _out_T_24
                    : io_release_curve_type == 3'h2
                        ? io_sustain - release_a * counter * counter
                        : out},
         {io_sustain},
         {_GEN_5
            ? out
            : io_decay_curve_type == 3'h0
                ? 32'hFFFFFFFF - decay_k * counter
                : io_decay_curve_type == 3'h1
                    ? io_sustain + decay_a * _out_T_9 * _out_T_9
                    : io_decay_curve_type == 3'h2
                        ? 32'hFFFFFFFF - decay_a * counter * counter
                        : out},
         {_GEN_3
            ? out
            : io_attack_curve_type == 3'h0
                ? attack_k * counter
                : io_attack_curve_type == 3'h1 ? attack_a * counter * counter : out},
         {io_note_on ? 32'h0 : out}};
      out <= _GEN_8[state];
      attack_k <= 32'hFFFFFFFF / io_attack;
      decay_k <= _decay_a_T / io_decay;
      release_k <= io_sustain / io_release;
      attack_a <= _attack_a_T_1[31:0];
      decay_a <= _decay_a_T_3[31:0];
      release_a <= _release_a_T_1[31:0];
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:8];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        for (logic [3:0] i = 4'h0; i < 4'h9; i += 4'h1) begin
          _RANDOM[i] = `RANDOM;
        end
        state = _RANDOM[4'h0][2:0];
        counter = {_RANDOM[4'h0][31:3], _RANDOM[4'h1][2:0]};
        out = {_RANDOM[4'h1][31:3], _RANDOM[4'h2][2:0]};
        attack_k = {_RANDOM[4'h2][31:3], _RANDOM[4'h3][2:0]};
        decay_k = {_RANDOM[4'h3][31:3], _RANDOM[4'h4][2:0]};
        release_k = {_RANDOM[4'h4][31:3], _RANDOM[4'h5][2:0]};
        attack_a = {_RANDOM[4'h5][31:3], _RANDOM[4'h6][2:0]};
        decay_a = {_RANDOM[4'h6][31:3], _RANDOM[4'h7][2:0]};
        release_a = {_RANDOM[4'h7][31:3], _RANDOM[4'h8][2:0]};
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_out = out;
endmodule

