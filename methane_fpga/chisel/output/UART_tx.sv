// Generated by CIRCT firtool-1.48.0
// Standard header to adapt well known macros to our needs.
`ifndef RANDOMIZE
  `ifdef RANDOMIZE_REG_INIT
    `define RANDOMIZE
  `endif // RANDOMIZE_REG_INIT
`endif // not def RANDOMIZE

// RANDOM may be set to an expression that produces a 32-bit random unsigned value.
`ifndef RANDOM
  `define RANDOM $random
`endif // not def RANDOM

// Users can define INIT_RANDOM as general code that gets injected into the
// initializer block for modules with registers.
`ifndef INIT_RANDOM
  `define INIT_RANDOM
`endif // not def INIT_RANDOM

// If using random initialization, you can also define RANDOMIZE_DELAY to
// customize the delay used, otherwise 0.002 is used.
`ifndef RANDOMIZE_DELAY
  `define RANDOMIZE_DELAY 0.002
`endif // not def RANDOMIZE_DELAY

// Define INIT_RANDOM_PROLOG_ for use in our modules below.
`ifndef INIT_RANDOM_PROLOG_
  `ifdef RANDOMIZE
    `ifdef VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM
    `else  // VERILATOR
      `define INIT_RANDOM_PROLOG_ `INIT_RANDOM #`RANDOMIZE_DELAY begin end
    `endif // VERILATOR
  `else  // RANDOMIZE
    `define INIT_RANDOM_PROLOG_
  `endif // RANDOMIZE
`endif // not def INIT_RANDOM_PROLOG_

// Include register initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_REG_
    `define ENABLE_INITIAL_REG_
  `endif // not def ENABLE_INITIAL_REG_
`endif // not def SYNTHESIS

// Include rmemory initializers in init blocks unless synthesis is set
`ifndef SYNTHESIS
  `ifndef ENABLE_INITIAL_MEM_
    `define ENABLE_INITIAL_MEM_
  `endif // not def ENABLE_INITIAL_MEM_
`endif // not def SYNTHESIS

module UART_tx(
  input        clock,
               reset,
               io_i_tx_trig,
  input  [7:0] io_i_data,
  output       io_o_tx_busy,
               io_o_tx_done,
               io_o_serial_data
);

  reg [7:0] clkCnterReg;
  reg [3:0] bitCnterReg;
  reg [7:0] inDataReg;
  reg       outDataReg;
  reg       outTxBusyReg;
  reg       outTxDoneReg;
  reg [1:0] stateReg;
  always @(posedge clock) begin
    if (reset) begin
      clkCnterReg <= 8'h0;
      bitCnterReg <= 4'h0;
      inDataReg <= 8'h0;
      outDataReg <= 1'h1;
      outTxBusyReg <= 1'h0;
      outTxDoneReg <= 1'h0;
      stateReg <= 2'h0;
    end
    else begin
      automatic logic            _GEN;
      automatic logic            _GEN_0;
      automatic logic            _GEN_1;
      automatic logic            _GEN_2;
      automatic logic [3:0][7:0] _GEN_3;
      automatic logic [3:0][1:0] _GEN_4;
      _GEN = stateReg == 2'h0;
      _GEN_0 = stateReg == 2'h1;
      _GEN_1 = clkCnterReg < 8'h56;
      _GEN_2 = stateReg == 2'h2;
      _GEN_3 =
        {{_GEN_1 ? clkCnterReg + 8'h1 : 8'h0},
         {_GEN_1 ? clkCnterReg + 8'h1 : 8'h0},
         {_GEN_1 ? clkCnterReg + 8'h1 : 8'h0},
         {8'h0}};
      clkCnterReg <= _GEN_3[stateReg];
      if (_GEN) begin
        bitCnterReg <= 4'h0;
        outDataReg <= ~io_i_tx_trig & outDataReg;
      end
      else begin
        automatic logic [7:0] _GEN_5;
        _GEN_5 = {4'h0, bitCnterReg};
        if (_GEN_0) begin
          if (~_GEN_1) begin
            automatic logic [7:0] _outDataReg_T;
            bitCnterReg <= bitCnterReg + 4'h1;
            _outDataReg_T = inDataReg >> _GEN_5;
            outDataReg <= _outDataReg_T[0];
          end
        end
        else if (~_GEN_2 | _GEN_1) begin
        end
        else begin
          automatic logic [7:0] _outDataReg_T_2;
          if (bitCnterReg[3])
            bitCnterReg <= 4'h0;
          else
            bitCnterReg <= bitCnterReg + 4'h1;
          _outDataReg_T_2 = inDataReg >> _GEN_5;
          outDataReg <= bitCnterReg[3] | _outDataReg_T_2[0];
        end
      end
      if (_GEN & io_i_tx_trig)
        inDataReg <= io_i_data;
      outTxBusyReg <= |stateReg;
      outTxDoneReg <= ~_GEN & (~(_GEN_0 | _GEN_2) & (&stateReg) & ~_GEN_1 | outTxDoneReg);
      _GEN_4 =
        {{{2{_GEN_1}}},
         {{1'h1, ~(_GEN_1 | ~(bitCnterReg[3]))}},
         {_GEN_1 ? 2'h1 : 2'h2},
         {{1'h0, io_i_tx_trig}}};
      stateReg <= _GEN_4[stateReg];
    end
  end // always @(posedge)
  `ifdef ENABLE_INITIAL_REG_
    `ifdef FIRRTL_BEFORE_INITIAL
      `FIRRTL_BEFORE_INITIAL
    `endif // FIRRTL_BEFORE_INITIAL
    initial begin
      automatic logic [31:0] _RANDOM[0:0];
      `ifdef INIT_RANDOM_PROLOG_
        `INIT_RANDOM_PROLOG_
      `endif // INIT_RANDOM_PROLOG_
      `ifdef RANDOMIZE_REG_INIT
        _RANDOM[/*Zero width*/ 1'b0] = `RANDOM;
        clkCnterReg = _RANDOM[/*Zero width*/ 1'b0][7:0];
        bitCnterReg = _RANDOM[/*Zero width*/ 1'b0][11:8];
        inDataReg = _RANDOM[/*Zero width*/ 1'b0][19:12];
        outDataReg = _RANDOM[/*Zero width*/ 1'b0][20];
        outTxBusyReg = _RANDOM[/*Zero width*/ 1'b0][21];
        outTxDoneReg = _RANDOM[/*Zero width*/ 1'b0][22];
        stateReg = _RANDOM[/*Zero width*/ 1'b0][24:23];
      `endif // RANDOMIZE_REG_INIT
    end // initial
    `ifdef FIRRTL_AFTER_INITIAL
      `FIRRTL_AFTER_INITIAL
    `endif // FIRRTL_AFTER_INITIAL
  `endif // ENABLE_INITIAL_REG_
  assign io_o_tx_busy = outTxBusyReg;
  assign io_o_tx_done = outTxDoneReg;
  assign io_o_serial_data = outDataReg;
endmodule

